diff --git a/pdxparse.cabal b/pdxparse.cabal
index 368be02..4e86f95 100644
--- a/pdxparse.cabal
+++ b/pdxparse.cabal
@@ -1,4 +1,4 @@
--- Initial pdxparse.cabal generated by cabal init.  For further 
+-- Initial pdxparse.cabal generated by cabal init.  For further
 -- documentation, see http://haskell.org/cabal/users-guide/
 
 name:                pdxparse
@@ -79,7 +79,7 @@ executable pdxparse
                        TemplateHaskell,
                        TypeFamilies,
                        ViewPatterns
-  
+
 --  build-depends:       base >=4.7 && <4.9,
 --                       array >= 0.5 && < 0.6,
 --                       attoparsec >=0.13 && <0.14,
@@ -88,7 +88,6 @@ executable pdxparse
 --                       containers >=0.5 && <0.6,
 --                       directory >=1.2 && <1.3,
 --                       filepath >=1.3 && <1.5,
---                       haskell-src-exts-qq >=0.7 && <0.8,
 --                       haskell-src-meta >=0.6 && <0.7,
 --                       monad-logger >=0.3 && <0.4,
 --                       mtl >=2.1 && <2.3,
@@ -109,7 +108,6 @@ executable pdxparse
                        directory >=1.2,
                        filepath >=1.3,
                        hashable >=1.2,
-                       haskell-src-exts-qq >=0.7,
                        haskell-src-meta >=0.6,
                        monad-logger >=0.3,
                        mtl >=2.1,
@@ -124,7 +122,7 @@ executable pdxparse
                        yaml >=0.8
   if os(windows)
     build-depends:     Win32
-  
+
   hs-source-dirs:      src
   if os(windows)
     hs-source-dirs:    os/win32
@@ -132,8 +130,8 @@ executable pdxparse
     hs-source-dirs:    os/unix
 
   default-language:    Haskell2010
-  ghc-options:         -fwarn-incomplete-patterns -fmax-pmcheck-iterations=3000000 -Werror
-  
+  ghc-options:         -fwarn-incomplete-patterns -fmax-pmcheck-models=3000000 -Werror
+
 source-repository head
   type:            git
   location:        https://github.com/HairyDude/pdxparse
diff --git a/src/Abstract.hs b/src/Abstract.hs
index 0764805..5093ea1 100644
--- a/src/Abstract.hs
+++ b/src/Abstract.hs
@@ -61,21 +61,21 @@ module Abstract (
 
 import Control.Applicative (Applicative (..), Alternative (..))
 import Control.Monad (void)
-import qualified Data.Foldable as F
-import Data.Monoid (Monoid (..), (<>))
 
+import qualified Data.Foldable as F
 import Data.Char (isAlpha, isAlphaNum, isDigit, isSpace)
 import Data.List (intersperse)
 import Data.Maybe (fromMaybe)
-
+import Data.Monoid
 import Data.Text (Text)
 import qualified Data.Text as T
 import qualified Data.Text.Lazy as TL
+import Data.Void
 
 import Data.Attoparsec.Text (Parser, (<?>))
 import qualified Data.Attoparsec.Text as Ap
 
-import Text.PrettyPrint.Leijen.Text (Doc, (<++>))
+import Doc (Doc, (<++>))
 import qualified Text.PrettyPrint.Leijen.Text as PP
 
 import qualified Doc
@@ -91,7 +91,7 @@ data Statement lhs rhs
         | Statement (Lhs lhs) Operator (Rhs lhs rhs)
     deriving (Eq, Ord, Show, Read)
 -- | Statement with no custom components.
-type GenericStatement = Statement () ()
+type GenericStatement = Statement Void Void
 
 -- | The operator between the two sides of a statement. Usually an equals sign,
 -- but can be less than or greater than.
@@ -127,7 +127,7 @@ data Lhs lhs
     | IntLhs Int                    -- ^ 1234 = ...
     deriving (Eq, Ord, Show, Read)
 -- | LHS with no custom elements.
-type GenericLhs = Lhs ()
+type GenericLhs = Lhs Void
 
 -- | Type of statement right-hand sides (the part after the '='). Since this is
 -- mutually recursive with 'Statement', it also requires the custom LHS type as
@@ -146,8 +146,9 @@ data Rhs lhs rhs
     | CompoundRhs [Statement lhs rhs] -- ^ ... = { ... }
     | DateRhs Date                  -- ^ ... = 11.10.1234
     deriving (Eq, Ord, Show, Read)
+
 -- | RHS with no custom elements.
-type GenericRhs = Rhs () ()
+type GenericRhs = Rhs Void Void
 
 -- | Script, i.e. list of statements.
 type Script lhs rhs = [Statement lhs rhs]
@@ -370,7 +371,7 @@ rhs customLhs customRhs
         <|> GenericRhs  <$> ident <*> Ap.many' (":" *> ident)
         <|> CompoundRhs <$> compoundRhs customLhs customRhs)
         <|> StringRhs   <$> "---" -- FIXME: Hack to work around weird "set_revolution_target = ---" line in the center_of_revolution.1500 event
-        -- Need solution for variables like ^ ... = whatever?0 
+        -- Need solution for variables like ^ ... = whatever?0
     <?> "statement RHS"
 
 -- | A RHS that consists of multiple statements grouped by braces. Frequently
diff --git a/src/Doc.hs b/src/Doc.hs
index bfd8ed7..0949855 100644
--- a/src/Doc.hs
+++ b/src/Doc.hs
@@ -2,15 +2,16 @@
 Module      : Doc
 Description : Front end to Wadler/Leijen pretty printer
 -}
-module Doc (
-        strictText
-    ,   pp_string
-    ,   doc2text
-    ,   pp_signed, pp_nosigned
-    ,   pp_float
-    ,   pp_float_t
-    ,   nl2br
-    ,   Doc
+module Doc
+    ( strictText
+    , pp_string
+    , doc2text
+    , pp_signed, pp_nosigned
+    , pp_float
+    , pp_float_t
+    , nl2br
+    , Doc
+    , (PP.<++>)
     ) where
 
 import Data.List (unfoldr)
@@ -55,11 +56,14 @@ pp_nosigned pp_num n =
 -- | Pretty-print a Double. If it's a whole number, display it without a
 -- decimal.
 pp_float :: Double -> Doc
-pp_float n =
-    let trunc = floor n :: Int
-    in if fromIntegral trunc == n
-        then PP.int (fromIntegral trunc)
-        else PP.text . TL.pack $ showFFloat Nothing n ""
+pp_float n
+    | fromIntegral trunc == n =
+        PP.int (fromIntegral trunc)
+    | otherwise =
+        PP.text . TL.pack $ showFFloat Nothing n ""
+    where
+    trunc :: Int
+    trunc = floor n
 
 -- | Pretty-print a Double, as Text.
 pp_float_t :: Double -> Text
diff --git a/src/EU4/Common.hs b/src/EU4/Common.hs
index b757f94..5a9ca8f 100644
--- a/src/EU4/Common.hs
+++ b/src/EU4/Common.hs
@@ -88,7 +88,7 @@ ppHandlers = foldl' Tr.unionL Tr.empty
     , handlersLocRhs
     , handlersProvince
     , handlersFlagOrProvince
-    , handlersNumericOrFlag 
+    , handlersNumericOrFlag
     , handlersAdvisorId
     , handlersTypewriter
     , handlersSimpleIcon
@@ -1842,7 +1842,7 @@ ppOne stmt@[pdx| %lhs = %rhs |] = case lhs of
              then case rhs of
                 CompoundRhs scr ->
                     withCurrentIndent $ \_ -> do -- force indent level at least 1
-                        [lflag] <- plainMsg =<< (<> ":") <$> flagText (Just EU4Country) label
+                        lflag <- plainMsg' =<< (<> ":") <$> flagText (Just EU4Country) label
                         scriptMsgs <- scope EU4Country $ ppMany scr
                         return (lflag : scriptMsgs)
                 _ -> preStatement stmt
@@ -1924,7 +1924,7 @@ ppMaybeGeo label loc scr = do
     case HM.lookup label geoData of
         Just geoType -> do
             inEffect <- getIsInEffect
-            [header] <- plainMsg $ (if isJust mtypeStmt || inEffect then "All provinces" else "Any province")
+            header <- plainMsg' $ (if isJust mtypeStmt || inEffect then "All provinces" else "Any province")
                 <> " in the " <> loc <> " " <> (describe geoType) <> ":"
             scriptMsgs <- scope EU4Province $ ppMany rest
             return (header : scriptMsgs)
@@ -1933,7 +1933,7 @@ ppMaybeGeo label loc scr = do
                     EU4Country
                 else
                     EU4Province
-            [header] <- plainMsg $ loc <> ":"
+            header <- plainMsg' $ loc <> ":"
             scriptMsgs <- scope actScope $ ppMany scr
             return (header : scriptMsgs)
 
diff --git a/src/EU4/Extra.hs b/src/EU4/Extra.hs
index 8160586..81b099d 100644
--- a/src/EU4/Extra.hs
+++ b/src/EU4/Extra.hs
@@ -19,7 +19,7 @@ import qualified Text.PrettyPrint.Leijen.Text as PP
 
 import Abstract
 import EU4.Common
-import EU4.Handlers (plainMsg)
+import EU4.Handlers (plainMsg')
 import FileIO (Feature (..), writeFeatures)
 import Messages (imsg2doc, IndentedMessages)
 import QQ (pdx)
@@ -88,7 +88,7 @@ ppExtraLine stmt@[pdx| $lhs = @scr |] = do
     let label = case loc of
                     Just t -> t <> "<!-- " <> lhs <> " -->"
                     _ -> lhs
-    [labMsg] <- plainMsg (label <> ":")
+    labMsg <- plainMsg' (label <> ":")
     msgs <- ppMany scr
     return (labMsg : msgs)
 ppExtraLine stmt = ppOne stmt
diff --git a/src/EU4/Handlers.hs b/src/EU4/Handlers.hs
index d1e9348..69a4b55 100644
--- a/src/EU4/Handlers.hs
+++ b/src/EU4/Handlers.hs
@@ -1,14 +1,16 @@
 module EU4.Handlers (
         preStatement
     ,   plainMsg
+    ,   plainMsg'
     ,   msgToPP
+    ,   msgToPP'
     ,   flagText
     ,   isTag
     ,   getProvLoc
     ,   pp_mtth
     ,   compound
     ,   compoundMessage
-    ,   compoundMessagePronoun 
+    ,   compoundMessagePronoun
     ,   compoundMessageTagged
     ,   allowPronoun
     ,   withLocAtom
@@ -31,12 +33,12 @@ module EU4.Handlers (
     ,   numeric
     ,   numericOrTag
     ,   numericOrTagIcon
-    ,   numericIconChange 
+    ,   numericIconChange
     ,   buildingCount
-    ,   withFlag 
+    ,   withFlag
     ,   withBool
     ,   withFlagOrBool
-    ,   withTagOrNumber 
+    ,   withTagOrNumber
     ,   numericIcon
     ,   numericIconLoc
     ,   numericIconBonus
@@ -90,7 +92,7 @@ module EU4.Handlers (
     ,   setGovtRank
     ,   numProvinces
     ,   withFlagOrProvince
-    ,   withFlagOrProvinceEU4Scope 
+    ,   withFlagOrProvinceEU4Scope
     ,   tradeMod
     ,   isMonth
     ,   range
@@ -205,7 +207,7 @@ import Debug.Trace
 preStatement :: (EU4Info g, Monad m) =>
     GenericStatement -> PPT g m IndentedMessages
 preStatement [pdx| %lhs = @scr |] = do
-    [headerMsg] <- plainMsg $ "<pre>" <> Doc.doc2text (lhs2doc (const "") lhs) <> "</pre>"
+    headerMsg <- plainMsg' $ "<pre>" <> Doc.doc2text (lhs2doc (const "") lhs) <> "</pre>"
     msgs <- ppMany scr
     return (headerMsg : msgs)
 preStatement stmt = (:[]) <$> alsoIndent' (preMessage stmt)
@@ -232,10 +234,16 @@ preMessage = MsgUnprocessed
 -- | Create a generic message from a piece of text. The rendering function will
 -- pass this through unaltered.
 plainMsg :: (IsGameState (GameState g), Monad m) => Text -> PPT g m IndentedMessages
-plainMsg msg = (:[]) <$> (alsoIndent' . MsgUnprocessed $ msg)
+plainMsg msg = (:[]) <$> plainMsg' msg
+
+plainMsg' :: (IsGameState (GameState g), Monad m) => Text -> PPT g m IndentedMessage
+plainMsg' msg = (alsoIndent' . MsgUnprocessed $ msg)
 
 msgToPP :: (IsGameState (GameState g), Monad m) => ScriptMessage -> PPT g m IndentedMessages
-msgToPP msg = (:[]) <$> alsoIndent' msg
+msgToPP msg = (:[]) <$> msgToPP' msg
+
+msgToPP' :: (IsGameState (GameState g), Monad m) => ScriptMessage -> PPT g m IndentedMessage
+msgToPP' msg = alsoIndent' msg
 
 -- Emit icon template.
 icon :: Text -> Doc
@@ -585,7 +593,7 @@ withLocAtomAndIcon :: (EU4Info g, Monad m) =>
          -- <https://www.eu4wiki.com/Template:Icon Template:Icon> on the wiki
         -> (Text -> Text -> ScriptMessage)
         -> StatementHandler g m
-withLocAtomAndIcon iconkey msg stmt@[pdx| %_ = $vartag:$var |] = do 
+withLocAtomAndIcon iconkey msg stmt@[pdx| %_ = $vartag:$var |] = do
     mtagloc <- tagged vartag var
     case mtagloc of
         Just tagloc -> msgToPP $ msg (iconText iconkey) tagloc
@@ -1543,7 +1551,7 @@ taTypeFlag _ _ _ stmt = preStatement stmt
 -- | Helper for effects, where the argument is a single statement in a clause
 -- E.g. generate_traitor_advisor_effect
 
-getEffectArg :: Text -> GenericStatement -> Maybe (Rhs () ())
+getEffectArg :: Text -> GenericStatement -> Maybe GenericRhs
 getEffectArg tArg stmt@[pdx| %_ = @scr |] = case scr of
         [[pdx| $arg = %val |]] | T.toLower arg == tArg -> Just val
         _ -> Nothing
@@ -2392,115 +2400,115 @@ defineDynMember msgNew msgNewLeader msgNewAttribs msgNewLeaderAttribs [pdx| %_ =
         pp_define_dyn_member_attrib :: DefineDynMember -> PPT g m (Maybe (IndentedMessage, DefineDynMember))
         -- "Named <foo>"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_name = Just name } = do
-            [msg] <- msgToPP (MsgNamed name)
+            msg <- msgToPP' (MsgNamed name)
             return (Just (msg, ddm { ddm_name = Nothing }))
         -- "Of the <foo> dynasty"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_dynasty = Just dynasty } =
             case dynasty of
                 DynText dyntext -> do
-                    [msg] <- msgToPP (MsgNewDynMemberDynasty dyntext)
+                    msg <- msgToPP' (MsgNewDynMemberDynasty dyntext)
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
                 DynPron dyntext -> do
-                    [msg] <- msgToPP (MsgNewDynMemberDynastyAs dyntext)
+                    msg <- msgToPP' (MsgNewDynMemberDynastyAs dyntext)
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
                 DynOriginal -> do
-                    [msg] <- msgToPP MsgNewDynMemberOriginalDynasty
+                    msg <- msgToPP' MsgNewDynMemberOriginalDynasty
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
                 DynHistoric -> do
-                    [msg] <- msgToPP MsgNewDynMemberHistoricDynasty
+                    msg <- msgToPP' MsgNewDynMemberHistoricDynasty
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
         -- "Aged <foo> years"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_age = Just age } = do
-            [msg] <- msgToPP (MsgNewDynMemberAge age)
+            msg <- msgToPP' (MsgNewDynMemberAge age)
             return (Just (msg, ddm { ddm_age = Nothing }))
         -- "With {{icon|adm}} <foo> administrative skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_adm = Just adm, ddm_fixed = fixed } = do
-            [msg] <- msgToPP (MsgNewDynMemberAdm fixed (fromIntegral adm))
+            msg <- msgToPP' (MsgNewDynMemberAdm fixed (fromIntegral adm))
             return (Just (msg, ddm { ddm_adm = Nothing }))
         -- "With {{icon|adm}} <foo> diplomatic skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_dip = Just dip, ddm_fixed = fixed } = do
-            [msg] <- msgToPP (MsgNewDynMemberDip fixed (fromIntegral dip))
+            msg <- msgToPP' (MsgNewDynMemberDip fixed (fromIntegral dip))
             return (Just (msg, ddm { ddm_dip = Nothing }))
         -- "With {{icon|adm}} <foo> military skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_mil = Just mil, ddm_fixed = fixed } = do
-            [msg] <- msgToPP (MsgNewDynMemberMil fixed (fromIntegral mil))
+            msg <- msgToPP' (MsgNewDynMemberMil fixed (fromIntegral mil))
             return (Just (msg, ddm { ddm_mil = Nothing }))
         -- "At most <foo> skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_adm = Just adm } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxAdm (fromIntegral adm))
+            msg <- msgToPP' (MsgNewDynMemberMaxAdm (fromIntegral adm))
             return (Just (msg, ddm { ddm_max_adm = Nothing }))
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_dip = Just dip } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxDip (fromIntegral dip))
+            msg <- msgToPP' (MsgNewDynMemberMaxDip (fromIntegral dip))
             return (Just (msg, ddm { ddm_max_dip = Nothing }))
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_mil = Just mil } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxMil (fromIntegral mil))
+            msg <- msgToPP' (MsgNewDynMemberMaxMil (fromIntegral mil))
             return (Just (msg, ddm { ddm_max_mil = Nothing }))
         -- "Claim strength <foo>"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_claim = Just claim } = do
-            [msg] <- msgToPP $ MsgNewDynMemberClaim claim
+            msg <- msgToPP' $ MsgNewDynMemberClaim claim
             return (Just (msg, ddm { ddm_claim = Nothing }))
         -- "Of the <foo> culture"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_culture = Just culture } = case culture of
             Left cultureText -> do
               locCulture <- getGameL10n cultureText
-              [msg] <- msgToPP $ MsgNewDynMemberCulture locCulture
+              msg <- msgToPP' $ MsgNewDynMemberCulture locCulture
               return (Just (msg, ddm { ddm_culture = Nothing }))
             Right cultureText -> do
-              [msg] <- msgToPP $ MsgNewDynMemberCultureAs cultureText
+              msg <- msgToPP' $ MsgNewDynMemberCultureAs cultureText
               return (Just (msg, ddm { ddm_culture = Nothing }))
         -- "Following the <foo> religion"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_religion = Just religion } = case religion of
             Left religionText  -> do
               locReligion <- getGameL10n religionText
-              [msg] <- msgToPP $ MsgNewDynMemberReligion (iconText religionText) locReligion
+              msg <- msgToPP' $ MsgNewDynMemberReligion (iconText religionText) locReligion
               return (Just (msg, ddm { ddm_religion = Nothing }))
             Right religionText -> do
-              [msg] <- msgToPP $ MsgNewDynMemberReligionAs religionText
+              msg <- msgToPP' $ MsgNewDynMemberReligionAs religionText
               return (Just (msg, ddm { ddm_religion = Nothing }))
         -- "With skills hidden"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_hidden_skills = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberHiddenSkills
+            msg <- msgToPP' $ MsgNewDynMemberHiddenSkills
             return (Just (msg, ddm { ddm_hidden_skills = False }))
         -- Random gender
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_random_gender = Just True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberRandomGender
+            msg <- msgToPP' $ MsgNewDynMemberRandomGender
             return (Just (msg, ddm { ddm_random_gender = Nothing }))
         -- Assigned gender
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_female = Just female } = do
-            [msg] <- msgToPP $ MsgWithGender (not female)
+            msg <- msgToPP' $ MsgWithGender (not female)
             return (Just (msg, ddm { ddm_female = Nothing }))
         -- Min age
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_min_age = Just age } = do
-            [msg] <- msgToPP (MsgNewDynMemberMinAge (fromIntegral age))
+            msg <- msgToPP' (MsgNewDynMemberMinAge (fromIntegral age))
             return (Just (msg, ddm { ddm_min_age = Nothing }))
         -- Max age
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_age = Just age } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxAge (fromIntegral age))
+            msg <- msgToPP' (MsgNewDynMemberMaxAge (fromIntegral age))
             return (Just (msg, ddm { ddm_max_age = Nothing }))
         -- Disinherit blockde
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_block_disinherit = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberBlockDisinherit
+            msg <- msgToPP' $ MsgNewDynMemberBlockDisinherit
             return (Just (msg, ddm { ddm_block_disinherit = False }))
         -- Birth date
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_birth_date = Just date } = do
-            [msg] <- msgToPP $ MsgNewDynMemberBirthdate date
+            msg <- msgToPP' $ MsgNewDynMemberBirthdate date
             return (Just (msg, ddm { ddm_birth_date = Nothing }))
         -- Bastard
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_bastard = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberBastard
+            msg <- msgToPP' $ MsgNewDynMemberBastard
             return (Just (msg, ddm { ddm_bastard = False }))
         -- Country of origin
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_country = Just country } = do
             countryText <- flagText (Just EU4Country) country
-            [msg] <- msgToPP $ MsgNewDynMemberCountry countryText
+            msg <- msgToPP' $ MsgNewDynMemberCountry countryText
             return (Just (msg, ddm { ddm_country = Nothing }))
         -- Exile name
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_exiled_as = Just exiled_as } = do
-            [msg] <- msgToPP (MsgExiledAs exiled_as)
+            msg <- msgToPP' (MsgExiledAs exiled_as)
             return (Just (msg, ddm { ddm_exiled_as = Nothing }))
         -- Force republican names
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_force_republican_names = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberForceRepublicanNames
+            msg <- msgToPP' $ MsgNewDynMemberForceRepublicanNames
             return (Just (msg, ddm { ddm_force_republican_names = False }))
         -- Nothing left
         pp_define_dyn_member_attrib _ = return Nothing
@@ -2796,7 +2804,8 @@ triggerSwitch stmt@(Statement _ OpEq (CompoundRhs
                 [pdx| $condrhs = @action |] -> do
                     -- construct a fake condition to pp
                     let cond = [pdx| $condlhs = $condrhs |]
-                    ((_, guardMsg):_) <- ppOne cond -- XXX: match may fail (but shouldn't)
+                    guardMsg' <- ppOne cond
+                    let ((_, guardMsg):_) = guardMsg' -- XXX: match may fail (but shouldn't)
                     guardText <- messageText guardMsg
                     -- pp the rest of the block, at the next level (done automatically by ppMany)
                     statementMsgs <- ppMany action
@@ -2806,7 +2815,7 @@ triggerSwitch stmt@(Statement _ OpEq (CompoundRhs
 triggerSwitch stmt = preStatement stmt
 
 -- | Handle @calc_true_if@ clauses, of the following form:
--- 
+--
 -- @
 --  calc_true_if = {
 --       <conditions>
@@ -3193,39 +3202,39 @@ employedAdvisor stmt@[pdx| %_ = @scr |] = do
                     Administrative -> MsgEmployedAdvisorAdmin
                     Diplomatic -> MsgEmployedAdvisorDiplo
                     Military -> MsgEmployedAdvisorMiltary
-            [msg] <- msgToPP mt
+            msg <- msgToPP' mt
             return (Just (msg, ea { ea_category = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_type = Just typ } = do
             (t, i) <- tryLocAndIcon typ
-            [msg] <- msgToPP $ MsgEmployedAdvisorType t i
+            msg <- msgToPP' $ MsgEmployedAdvisorType t i
             return (Just (msg, ea { ea_type = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_male = Just male } = do
-            [msg] <- msgToPP $ MsgEmployedAdvisorMale male
+            msg <- msgToPP' $ MsgEmployedAdvisorMale male
             return (Just (msg, ea { ea_male = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_culture = Just culture } =
             if isPronoun culture then do
                 text <- Doc.doc2text <$> pronoun Nothing culture
-                [msg] <- msgToPP $ MsgCultureIsAs text
+                msg <- msgToPP' $ MsgCultureIsAs text
                 return (Just (msg, ea { ea_culture = Nothing }))
             else do
                 text <- getGameL10n culture
-                [msg] <- msgToPP $ MsgCultureIs text
+                msg <- msgToPP' $ MsgCultureIs text
                 return (Just (msg, ea { ea_culture = Nothing }))
         -- TODO: Better localization (neither heretic nor heathen seem to be in the localization files)
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_religion = Just "heretic" } = do
-            [msg] <- msgToPP $ MsgReligion (iconText "tolerance heretic") "hertical"
+            msg <- msgToPP' $ MsgReligion (iconText "tolerance heretic") "hertical"
             return (Just (msg, ea { ea_religion = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_religion = Just "heathen" } = do
-            [msg] <- msgToPP $ MsgReligion (iconText "tolerance heathen") "heathen"
+            msg <- msgToPP' $ MsgReligion (iconText "tolerance heathen") "heathen"
             return (Just (msg, ea { ea_religion = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_religion = Just religion } =
             if isPronoun religion then do
                 text <- Doc.doc2text <$> pronoun Nothing religion
-                [msg] <- msgToPP $ MsgSameReligion text
+                msg <- msgToPP' $ MsgSameReligion text
                 return (Just (msg, ea { ea_religion = Nothing }))
             else do
                 (t, i) <- tryLocAndIcon religion
-                [msg] <- msgToPP $ MsgReligion i t
+                msg <- msgToPP' $ MsgReligion i t
                 return (Just (msg, ea { ea_religion = Nothing }))
         pp_employed_advisor_attrib _ = return Nothing
 
@@ -3333,29 +3342,29 @@ pp_mil_leader_attrib naval ml =
 
         pp_mil_leader_attrib' :: MilitaryLeader -> PPT g m (Maybe (IndentedMessage, MilitaryLeader))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_tradition = Just trad } = do
-            [msg] <- msgToPP $ MsgLeaderTradition naval trad
+            msg <- msgToPP' $ MsgLeaderTradition naval trad
             return (Just (msg, ml { ml_tradition = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_shock = Just shock } = do
-            [msg] <- msgToPP $ msgShock shock
+            msg <- msgToPP' $ msgShock shock
             return (Just (msg, ml { ml_shock = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_fire = Just fire } = do
-            [msg] <- msgToPP $ msgFire fire
+            msg <- msgToPP' $ msgFire fire
             return (Just (msg, ml { ml_fire = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_manuever = Just manuever } = do
-            [msg] <- msgToPP $ msgManuever manuever
+            msg <- msgToPP' $ msgManuever manuever
             return (Just (msg, ml { ml_manuever = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_siege = Just siege } = do
-            [msg] <- msgToPP $ msgSiege siege
+            msg <- msgToPP' $ msgSiege siege
             return (Just (msg, ml { ml_siege = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_name = Just name } = do
-            [msg] <- msgToPP $ MsgNamed name
+            msg <- msgToPP' $ MsgNamed name
             return (Just (msg, ml { ml_name = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_female = Just True } = do
-            [msg] <- msgToPP $ MsgWithGender False
+            msg <- msgToPP' $ MsgWithGender False
             return (Just (msg, ml { ml_female = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_trait = Just trait } = do
             text <- getGameL10n trait
-            [msg] <- msgToPP $ MsgMilitaryLeaderTrait text
+            msg <- msgToPP' $ MsgMilitaryLeaderTrait text
             return (Just (msg, ml { ml_trait = Nothing }))
         pp_mil_leader_attrib' _ = return Nothing
     in
@@ -3561,13 +3570,13 @@ randomAdvisor stmt@[pdx| %_ = @scr |] = pp_ra (foldl' addLine newRA scr)
         pp_ra_attrib :: RandomAdvisor -> PPT g m (Maybe (IndentedMessage, RandomAdvisor))
         pp_ra_attrib ra@RandomAdvisor{ra_type_non_state = Just typ} | T.toLower typ /= maybe "" T.toLower (ra_type ra) = do
             (t, i) <- tryLocAndIcon typ
-            [msg] <- msgToPP $ MsgRandomAdvisorNonState i t
+            msg <- msgToPP' $ MsgRandomAdvisorNonState i t
             return (Just (msg, ra { ra_type_non_state = Nothing }))
         pp_ra_attrib ra@RandomAdvisor{ra_skill = Just skill} = do
-            [msg] <- msgToPP $ MsgRandomAdvisorSkill skill
+            msg <- msgToPP' $ MsgRandomAdvisorSkill skill
             return (Just (msg, ra { ra_skill = Nothing }))
         pp_ra_attrib ra@RandomAdvisor{ra_scaled_skill = True} = do
-            [msg] <- msgToPP $ MsgRandomAdvisorScaledSkill
+            msg <- msgToPP' $ MsgRandomAdvisorScaledSkill
             return (Just (msg, ra { ra_scaled_skill = False }))
         pp_ra_attrib ra = return Nothing
 
@@ -3691,7 +3700,7 @@ aiAttitude msg stmt@[pdx| %_ = @scr |] =
         pp_aia isLocked ta = case (ta_what ta, ta_atom ta) of
             (Just who, Just attitude) -> do
                 let tags = T.splitOn ":" who -- A bit of a hack
-                    icon = (iconText attitude) 
+                    icon = (iconText attitude)
                 attLoc <- getGameL10n attitude
                 if length tags == 2 then do
                     taggedLoc <- tagged (tags !! 0) (tags !! 1)
@@ -3876,7 +3885,7 @@ hasLeaderWith stmt@[pdx| %_ = @scr |] = pp_hlw (foldl' addLine newHLW scr)
 
         pp_hlw_attrib :: HasLeaderWith -> PPT g m (Maybe (IndentedMessage, HasLeaderWith))
         pp_hlw_attrib hlw@HasLeaderWith { hlw_total_pips = Just pips } = do
-            [msg] <- msgToPP $ MsgTotalPips pips
+            msg <- msgToPP' $ MsgTotalPips pips
             return (Just (msg, hlw { hlw_total_pips = Nothing }))
         pp_hlw_attrib _ = return Nothing
 
diff --git a/src/EU4/Templates.hs b/src/EU4/Templates.hs
index 094ae3b..73bd13d 100644
--- a/src/EU4/Templates.hs
+++ b/src/EU4/Templates.hs
@@ -84,7 +84,7 @@ foldCompound :: String -> String -> String -> [(String, Q Type)] -> [CompField]
 foldCompound funname s_tyname prefix extraArgs fieldspecs eval = do
     let -- Missing TH library function
         funT :: TypeQ -> TypeQ -> TypeQ
-        funT t1 t2 = [t| $t1 -> $t2 |] 
+        funT t1 t2 = [t| $t1 -> $t2 |]
         -- Variable names
         name_acc = mkName "acc"
         name_addLine = mkName "addLine"
@@ -151,7 +151,7 @@ foldCompound funname s_tyname prefix extraArgs fieldspecs eval = do
             dataD (cxt []) tyname [] Nothing
                   [recC tyname recFields
                   ]
-                  (cxt [])
+                  [DerivClause Nothing <$> cxt []]
         -- Initial accumulator
         -- new<AccType> :: <AccType>
         -- new<AccType> = AccType <default1> <default2> ...
diff --git a/src/HOI4/Common.hs b/src/HOI4/Common.hs
index 5e66009..e855472 100644
--- a/src/HOI4/Common.hs
+++ b/src/HOI4/Common.hs
@@ -88,7 +88,7 @@ ppHandlers = foldl' Tr.unionL Tr.empty
     , handlersLocRhs
     , handlersProvince
     , handlersFlagOrProvince
-    , handlersNumericOrFlag 
+    , handlersNumericOrFlag
     , handlersAdvisorId
     , handlersTypewriter
     , handlersSimpleIcon
@@ -1843,7 +1843,7 @@ ppOne stmt@[pdx| %lhs = %rhs |] = case lhs of
              then case rhs of
                 CompoundRhs scr ->
                     withCurrentIndent $ \_ -> do -- force indent level at least 1
-                        [lflag] <- plainMsg =<< (<> ":") <$> flagText (Just HOI4Country) label
+                        lflag <- plainMsg' =<< (<> ":") <$> flagText (Just HOI4Country) label
                         scriptMsgs <- scope HOI4Country $ ppMany scr
                         return (lflag : scriptMsgs)
                 _ -> preStatement stmt
@@ -1925,7 +1925,7 @@ ppMaybeGeo label loc scr = do
     case HM.lookup label geoData of
         Just geoType -> do
             inEffect <- getIsInEffect
-            [header] <- plainMsg $ (if isJust mtypeStmt || inEffect then "All provinces" else "Any province")
+            header <- plainMsg' $ (if isJust mtypeStmt || inEffect then "All provinces" else "Any province")
                 <> " in the " <> loc <> " " <> (describe geoType) <> ":"
             scriptMsgs <- scope HOI4Province $ ppMany rest
             return (header : scriptMsgs)
@@ -1934,7 +1934,7 @@ ppMaybeGeo label loc scr = do
                     HOI4Country
                 else
                     HOI4Province
-            [header] <- plainMsg $ loc <> ":"
+            header <- plainMsg' $ loc <> ":"
             scriptMsgs <- scope actScope $ ppMany scr
             return (header : scriptMsgs)
 
diff --git a/src/HOI4/Extra.hs b/src/HOI4/Extra.hs
index 9a78ba5..a4d3b19 100644
--- a/src/HOI4/Extra.hs
+++ b/src/HOI4/Extra.hs
@@ -19,7 +19,7 @@ import qualified Text.PrettyPrint.Leijen.Text as PP
 
 import Abstract
 import HOI4.Common
-import HOI4.Handlers (plainMsg)
+import HOI4.Handlers (plainMsg')
 import FileIO (Feature (..), writeFeatures)
 import Messages (imsg2doc, IndentedMessages)
 import QQ (pdx)
@@ -88,7 +88,7 @@ ppExtraLine stmt@[pdx| $lhs = @scr |] = do
     let label = case loc of
                     Just t -> t <> "<!-- " <> lhs <> " -->"
                     _ -> lhs
-    [labMsg] <- plainMsg (label <> ":")
+    labMsg <- plainMsg' (label <> ":")
     msgs <- ppMany scr
     return (labMsg : msgs)
 ppExtraLine stmt = ppOne stmt
diff --git a/src/HOI4/Handlers.hs b/src/HOI4/Handlers.hs
index 6cc2ce7..88819a7 100644
--- a/src/HOI4/Handlers.hs
+++ b/src/HOI4/Handlers.hs
@@ -1,14 +1,16 @@
 module HOI4.Handlers (
         preStatement
     ,   plainMsg
+    ,   plainMsg'
     ,   msgToPP
+    ,   msgToPP'
     ,   flagText
     ,   isTag
     ,   getStateLoc
     ,   pp_mtth
     ,   compound
     ,   compoundMessage
-    ,   compoundMessagePronoun 
+    ,   compoundMessagePronoun
     ,   compoundMessageTagged
     ,   allowPronoun
     ,   withLocAtom
@@ -31,12 +33,12 @@ module HOI4.Handlers (
     ,   numeric
     ,   numericOrTag
     ,   numericOrTagIcon
-    ,   numericIconChange 
+    ,   numericIconChange
     ,   buildingCount
-    ,   withFlag 
+    ,   withFlag
     ,   withBool
     ,   withFlagOrBool
-    ,   withTagOrNumber 
+    ,   withTagOrNumber
     ,   numericIcon
     ,   numericIconLoc
     ,   numericIconBonus
@@ -90,7 +92,7 @@ module HOI4.Handlers (
     ,   setGovtRank
     ,   numProvinces
     ,   withFlagOrProvince
-    ,   withFlagOrProvinceHOI4Scope 
+    ,   withFlagOrProvinceHOI4Scope
     ,   tradeMod
     ,   isMonth
     ,   range
@@ -205,7 +207,7 @@ import Debug.Trace
 preStatement :: (HOI4Info g, Monad m) =>
     GenericStatement -> PPT g m IndentedMessages
 preStatement [pdx| %lhs = @scr |] = do
-    [headerMsg] <- plainMsg $ "<pre>" <> Doc.doc2text (lhs2doc (const "") lhs) <> "</pre>"
+    headerMsg <- plainMsg' $ "<pre>" <> Doc.doc2text (lhs2doc (const "") lhs) <> "</pre>"
     msgs <- ppMany scr
     return (headerMsg : msgs)
 preStatement stmt = (:[]) <$> alsoIndent' (preMessage stmt)
@@ -232,10 +234,16 @@ preMessage = MsgUnprocessed
 -- | Create a generic message from a piece of text. The rendering function will
 -- pass this through unaltered.
 plainMsg :: (IsGameState (GameState g), Monad m) => Text -> PPT g m IndentedMessages
-plainMsg msg = (:[]) <$> (alsoIndent' . MsgUnprocessed $ msg)
+plainMsg msg = (:[]) <$> plainMsg' msg
+
+plainMsg' :: (IsGameState (GameState g), Monad m) => Text -> PPT g m IndentedMessage
+plainMsg' msg = alsoIndent' . MsgUnprocessed $ msg
 
 msgToPP :: (IsGameState (GameState g), Monad m) => ScriptMessage -> PPT g m IndentedMessages
-msgToPP msg = (:[]) <$> alsoIndent' msg
+msgToPP msg = (:[]) <$> msgToPP' msg
+
+msgToPP' :: (IsGameState (GameState g), Monad m) => ScriptMessage -> PPT g m IndentedMessage
+msgToPP' msg = alsoIndent' msg
 
 -- Emit icon template.
 icon :: Text -> Doc
@@ -585,7 +593,7 @@ withLocAtomAndIcon :: (HOI4Info g, Monad m) =>
          -- <https://www.hoi4wiki.com/Template:Icon Template:Icon> on the wiki
         -> (Text -> Text -> ScriptMessage)
         -> StatementHandler g m
-withLocAtomAndIcon iconkey msg stmt@[pdx| %_ = $vartag:$var |] = do 
+withLocAtomAndIcon iconkey msg stmt@[pdx| %_ = $vartag:$var |] = do
     mtagloc <- tagged vartag var
     case mtagloc of
         Just tagloc -> msgToPP $ msg (iconText iconkey) tagloc
@@ -1543,7 +1551,7 @@ taTypeFlag _ _ _ stmt = preStatement stmt
 -- | Helper for effects, where the argument is a single statement in a clause
 -- E.g. generate_traitor_advisor_effect
 
-getEffectArg :: Text -> GenericStatement -> Maybe (Rhs () ())
+getEffectArg :: Text -> GenericStatement -> Maybe GenericRhs
 getEffectArg tArg stmt@[pdx| %_ = @scr |] = case scr of
         [[pdx| $arg = %val |]] | T.toLower arg == tArg -> Just val
         _ -> Nothing
@@ -2396,115 +2404,115 @@ defineDynMember msgNew msgNewLeader msgNewAttribs msgNewLeaderAttribs [pdx| %_ =
         pp_define_dyn_member_attrib :: DefineDynMember -> PPT g m (Maybe (IndentedMessage, DefineDynMember))
         -- "Named <foo>"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_name = Just name } = do
-            [msg] <- msgToPP (MsgNamed name)
+            msg <- msgToPP' (MsgNamed name)
             return (Just (msg, ddm { ddm_name = Nothing }))
         -- "Of the <foo> dynasty"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_dynasty = Just dynasty } =
             case dynasty of
                 DynText dyntext -> do
-                    [msg] <- msgToPP (MsgNewDynMemberDynasty dyntext)
+                    msg <- msgToPP' (MsgNewDynMemberDynasty dyntext)
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
                 DynPron dyntext -> do
-                    [msg] <- msgToPP (MsgNewDynMemberDynastyAs dyntext)
+                    msg <- msgToPP' (MsgNewDynMemberDynastyAs dyntext)
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
                 DynOriginal -> do
-                    [msg] <- msgToPP MsgNewDynMemberOriginalDynasty
+                    msg <- msgToPP' MsgNewDynMemberOriginalDynasty
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
                 DynHistoric -> do
-                    [msg] <- msgToPP MsgNewDynMemberHistoricDynasty
+                    msg <- msgToPP' MsgNewDynMemberHistoricDynasty
                     return (Just (msg, ddm { ddm_dynasty = Nothing }))
         -- "Aged <foo> years"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_age = Just age } = do
-            [msg] <- msgToPP (MsgNewDynMemberAge age)
+            msg <- msgToPP' (MsgNewDynMemberAge age)
             return (Just (msg, ddm { ddm_age = Nothing }))
         -- "With {{icon|adm}} <foo> administrative skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_adm = Just adm, ddm_fixed = fixed } = do
-            [msg] <- msgToPP (MsgNewDynMemberAdm fixed (fromIntegral adm))
+            msg <- msgToPP' (MsgNewDynMemberAdm fixed (fromIntegral adm))
             return (Just (msg, ddm { ddm_adm = Nothing }))
         -- "With {{icon|adm}} <foo> diplomatic skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_dip = Just dip, ddm_fixed = fixed } = do
-            [msg] <- msgToPP (MsgNewDynMemberDip fixed (fromIntegral dip))
+            msg <- msgToPP' (MsgNewDynMemberDip fixed (fromIntegral dip))
             return (Just (msg, ddm { ddm_dip = Nothing }))
         -- "With {{icon|adm}} <foo> military skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_mil = Just mil, ddm_fixed = fixed } = do
-            [msg] <- msgToPP (MsgNewDynMemberMil fixed (fromIntegral mil))
+            msg <- msgToPP' (MsgNewDynMemberMil fixed (fromIntegral mil))
             return (Just (msg, ddm { ddm_mil = Nothing }))
         -- "At most <foo> skill"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_adm = Just adm } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxAdm (fromIntegral adm))
+            msg <- msgToPP' (MsgNewDynMemberMaxAdm (fromIntegral adm))
             return (Just (msg, ddm { ddm_max_adm = Nothing }))
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_dip = Just dip } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxDip (fromIntegral dip))
+            msg <- msgToPP' (MsgNewDynMemberMaxDip (fromIntegral dip))
             return (Just (msg, ddm { ddm_max_dip = Nothing }))
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_mil = Just mil } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxMil (fromIntegral mil))
+            msg <- msgToPP' (MsgNewDynMemberMaxMil (fromIntegral mil))
             return (Just (msg, ddm { ddm_max_mil = Nothing }))
         -- "Claim strength <foo>"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_claim = Just claim } = do
-            [msg] <- msgToPP $ MsgNewDynMemberClaim claim
+            msg <- msgToPP' $ MsgNewDynMemberClaim claim
             return (Just (msg, ddm { ddm_claim = Nothing }))
         -- "Of the <foo> culture"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_culture = Just culture } = case culture of
             Left cultureText -> do
               locCulture <- getGameL10n cultureText
-              [msg] <- msgToPP $ MsgNewDynMemberCulture locCulture
+              msg <- msgToPP' $ MsgNewDynMemberCulture locCulture
               return (Just (msg, ddm { ddm_culture = Nothing }))
             Right cultureText -> do
-              [msg] <- msgToPP $ MsgNewDynMemberCultureAs cultureText
+              msg <- msgToPP' $ MsgNewDynMemberCultureAs cultureText
               return (Just (msg, ddm { ddm_culture = Nothing }))
         -- "Following the <foo> religion"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_religion = Just religion } = case religion of
             Left religionText  -> do
               locReligion <- getGameL10n religionText
-              [msg] <- msgToPP $ MsgNewDynMemberReligion (iconText religionText) locReligion
+              msg <- msgToPP' $ MsgNewDynMemberReligion (iconText religionText) locReligion
               return (Just (msg, ddm { ddm_religion = Nothing }))
             Right religionText -> do
-              [msg] <- msgToPP $ MsgNewDynMemberReligionAs religionText
+              msg <- msgToPP' $ MsgNewDynMemberReligionAs religionText
               return (Just (msg, ddm { ddm_religion = Nothing }))
         -- "With skills hidden"
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_hidden_skills = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberHiddenSkills
+            msg <- msgToPP' $ MsgNewDynMemberHiddenSkills
             return (Just (msg, ddm { ddm_hidden_skills = False }))
         -- Random gender
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_random_gender = Just True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberRandomGender
+            msg <- msgToPP' $ MsgNewDynMemberRandomGender
             return (Just (msg, ddm { ddm_random_gender = Nothing }))
         -- Assigned gender
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_female = Just female } = do
-            [msg] <- msgToPP $ MsgWithGender (not female)
+            msg <- msgToPP' $ MsgWithGender (not female)
             return (Just (msg, ddm { ddm_female = Nothing }))
         -- Min age
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_min_age = Just age } = do
-            [msg] <- msgToPP (MsgNewDynMemberMinAge (fromIntegral age))
+            msg <- msgToPP' (MsgNewDynMemberMinAge (fromIntegral age))
             return (Just (msg, ddm { ddm_min_age = Nothing }))
         -- Max age
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_max_age = Just age } = do
-            [msg] <- msgToPP (MsgNewDynMemberMaxAge (fromIntegral age))
+            msg <- msgToPP' (MsgNewDynMemberMaxAge (fromIntegral age))
             return (Just (msg, ddm { ddm_max_age = Nothing }))
         -- Disinherit blockde
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_block_disinherit = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberBlockDisinherit
+            msg <- msgToPP' $ MsgNewDynMemberBlockDisinherit
             return (Just (msg, ddm { ddm_block_disinherit = False }))
         -- Birth date
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_birth_date = Just date } = do
-            [msg] <- msgToPP $ MsgNewDynMemberBirthdate date
+            msg <- msgToPP' $ MsgNewDynMemberBirthdate date
             return (Just (msg, ddm { ddm_birth_date = Nothing }))
         -- Bastard
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_bastard = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberBastard
+            msg <- msgToPP' $ MsgNewDynMemberBastard
             return (Just (msg, ddm { ddm_bastard = False }))
         -- Country of origin
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_country = Just country } = do
             countryText <- flagText (Just HOI4Country) country
-            [msg] <- msgToPP $ MsgNewDynMemberCountry countryText
+            msg <- msgToPP' $ MsgNewDynMemberCountry countryText
             return (Just (msg, ddm { ddm_country = Nothing }))
         -- Exile name
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_exiled_as = Just exiled_as } = do
-            [msg] <- msgToPP (MsgExiledAs exiled_as)
+            msg <- msgToPP' (MsgExiledAs exiled_as)
             return (Just (msg, ddm { ddm_exiled_as = Nothing }))
         -- Force republican names
         pp_define_dyn_member_attrib ddm@DefineDynMember { ddm_force_republican_names = True } = do
-            [msg] <- msgToPP $ MsgNewDynMemberForceRepublicanNames
+            msg <- msgToPP' $ MsgNewDynMemberForceRepublicanNames
             return (Just (msg, ddm { ddm_force_republican_names = False }))
         -- Nothing left
         pp_define_dyn_member_attrib _ = return Nothing
@@ -2800,7 +2808,8 @@ triggerSwitch stmt@(Statement _ OpEq (CompoundRhs
                 [pdx| $condrhs = @action |] -> do
                     -- construct a fake condition to pp
                     let cond = [pdx| $condlhs = $condrhs |]
-                    ((_, guardMsg):_) <- ppOne cond -- XXX: match may fail (but shouldn't)
+                    guardMsg' <- ppOne cond
+                    let ((_, guardMsg):_) = guardMsg' -- XXX: match may fail (but shouldn't)
                     guardText <- messageText guardMsg
                     -- pp the rest of the block, at the next level (done automatically by ppMany)
                     statementMsgs <- ppMany action
@@ -2810,7 +2819,7 @@ triggerSwitch stmt@(Statement _ OpEq (CompoundRhs
 triggerSwitch stmt = preStatement stmt
 
 -- | Handle @calc_true_if@ clauses, of the following form:
--- 
+--
 -- @
 --  calc_true_if = {
 --       <conditions>
@@ -3197,39 +3206,39 @@ employedAdvisor stmt@[pdx| %_ = @scr |] = do
                     Administrative -> MsgEmployedAdvisorAdmin
                     Diplomatic -> MsgEmployedAdvisorDiplo
                     Military -> MsgEmployedAdvisorMiltary
-            [msg] <- msgToPP mt
+            msg <- msgToPP' mt
             return (Just (msg, ea { ea_category = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_type = Just typ } = do
             (t, i) <- tryLocAndIcon typ
-            [msg] <- msgToPP $ MsgEmployedAdvisorType t i
+            msg <- msgToPP' $ MsgEmployedAdvisorType t i
             return (Just (msg, ea { ea_type = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_male = Just male } = do
-            [msg] <- msgToPP $ MsgEmployedAdvisorMale male
+            msg <- msgToPP' $ MsgEmployedAdvisorMale male
             return (Just (msg, ea { ea_male = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_culture = Just culture } =
             if isPronoun culture then do
                 text <- Doc.doc2text <$> pronoun Nothing culture
-                [msg] <- msgToPP $ MsgCultureIsAs text
+                msg <- msgToPP' $ MsgCultureIsAs text
                 return (Just (msg, ea { ea_culture = Nothing }))
             else do
                 text <- getGameL10n culture
-                [msg] <- msgToPP $ MsgCultureIs text
+                msg <- msgToPP' $ MsgCultureIs text
                 return (Just (msg, ea { ea_culture = Nothing }))
         -- TODO: Better localization (neither heretic nor heathen seem to be in the localization files)
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_religion = Just "heretic" } = do
-            [msg] <- msgToPP $ MsgReligion (iconText "tolerance heretic") "hertical"
+            msg <- msgToPP' $ MsgReligion (iconText "tolerance heretic") "hertical"
             return (Just (msg, ea { ea_religion = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_religion = Just "heathen" } = do
-            [msg] <- msgToPP $ MsgReligion (iconText "tolerance heathen") "heathen"
+            msg <- msgToPP' $ MsgReligion (iconText "tolerance heathen") "heathen"
             return (Just (msg, ea { ea_religion = Nothing }))
         pp_employed_advisor_attrib ea@EmployedAdvisor { ea_religion = Just religion } =
             if isPronoun religion then do
                 text <- Doc.doc2text <$> pronoun Nothing religion
-                [msg] <- msgToPP $ MsgSameReligion text
+                msg <- msgToPP' $ MsgSameReligion text
                 return (Just (msg, ea { ea_religion = Nothing }))
             else do
                 (t, i) <- tryLocAndIcon religion
-                [msg] <- msgToPP $ MsgReligion i t
+                msg <- msgToPP' $ MsgReligion i t
                 return (Just (msg, ea { ea_religion = Nothing }))
         pp_employed_advisor_attrib _ = return Nothing
 
@@ -3337,29 +3346,29 @@ pp_mil_leader_attrib naval ml =
 
         pp_mil_leader_attrib' :: MilitaryLeader -> PPT g m (Maybe (IndentedMessage, MilitaryLeader))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_tradition = Just trad } = do
-            [msg] <- msgToPP $ MsgLeaderTradition naval trad
+            msg <- msgToPP' $ MsgLeaderTradition naval trad
             return (Just (msg, ml { ml_tradition = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_shock = Just shock } = do
-            [msg] <- msgToPP $ msgShock shock
+            msg <- msgToPP' $ msgShock shock
             return (Just (msg, ml { ml_shock = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_fire = Just fire } = do
-            [msg] <- msgToPP $ msgFire fire
+            msg <- msgToPP' $ msgFire fire
             return (Just (msg, ml { ml_fire = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_manuever = Just manuever } = do
-            [msg] <- msgToPP $ msgManuever manuever
+            msg <- msgToPP' $ msgManuever manuever
             return (Just (msg, ml { ml_manuever = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_siege = Just siege } = do
-            [msg] <- msgToPP $ msgSiege siege
+            msg <- msgToPP' $ msgSiege siege
             return (Just (msg, ml { ml_siege = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_name = Just name } = do
-            [msg] <- msgToPP $ MsgNamed name
+            msg <- msgToPP' $ MsgNamed name
             return (Just (msg, ml { ml_name = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_female = Just True } = do
-            [msg] <- msgToPP $ MsgWithGender False
+            msg <- msgToPP' $ MsgWithGender False
             return (Just (msg, ml { ml_female = Nothing }))
         pp_mil_leader_attrib' ml@MilitaryLeader { ml_trait = Just trait } = do
             text <- getGameL10n trait
-            [msg] <- msgToPP $ MsgMilitaryLeaderTrait text
+            msg <- msgToPP' $ MsgMilitaryLeaderTrait text
             return (Just (msg, ml { ml_trait = Nothing }))
         pp_mil_leader_attrib' _ = return Nothing
     in
@@ -3565,13 +3574,13 @@ randomAdvisor stmt@[pdx| %_ = @scr |] = pp_ra (foldl' addLine newRA scr)
         pp_ra_attrib :: RandomAdvisor -> PPT g m (Maybe (IndentedMessage, RandomAdvisor))
         pp_ra_attrib ra@RandomAdvisor{ra_type_non_state = Just typ} | T.toLower typ /= maybe "" T.toLower (ra_type ra) = do
             (t, i) <- tryLocAndIcon typ
-            [msg] <- msgToPP $ MsgRandomAdvisorNonState i t
+            msg <- msgToPP' $ MsgRandomAdvisorNonState i t
             return (Just (msg, ra { ra_type_non_state = Nothing }))
         pp_ra_attrib ra@RandomAdvisor{ra_skill = Just skill} = do
-            [msg] <- msgToPP $ MsgRandomAdvisorSkill skill
+            msg <- msgToPP' $ MsgRandomAdvisorSkill skill
             return (Just (msg, ra { ra_skill = Nothing }))
         pp_ra_attrib ra@RandomAdvisor{ra_scaled_skill = True} = do
-            [msg] <- msgToPP $ MsgRandomAdvisorScaledSkill
+            msg <- msgToPP' $ MsgRandomAdvisorScaledSkill
             return (Just (msg, ra { ra_scaled_skill = False }))
         pp_ra_attrib ra = return Nothing
 
@@ -3695,7 +3704,7 @@ aiAttitude msg stmt@[pdx| %_ = @scr |] =
         pp_aia isLocked ta = case (ta_what ta, ta_atom ta) of
             (Just who, Just attitude) -> do
                 let tags = T.splitOn ":" who -- A bit of a hack
-                    icon = (iconText attitude) 
+                    icon = (iconText attitude)
                 attLoc <- getGameL10n attitude
                 if length tags == 2 then do
                     taggedLoc <- tagged (tags !! 0) (tags !! 1)
@@ -3880,7 +3889,7 @@ hasLeaderWith stmt@[pdx| %_ = @scr |] = pp_hlw (foldl' addLine newHLW scr)
 
         pp_hlw_attrib :: HasLeaderWith -> PPT g m (Maybe (IndentedMessage, HasLeaderWith))
         pp_hlw_attrib hlw@HasLeaderWith { hlw_total_pips = Just pips } = do
-            [msg] <- msgToPP $ MsgTotalPips pips
+            msg <- msgToPP' $ MsgTotalPips pips
             return (Just (msg, hlw { hlw_total_pips = Nothing }))
         pp_hlw_attrib _ = return Nothing
 
@@ -4146,7 +4155,7 @@ foldCompound "addBuildingConstruction" "BuildingConstruction" "bc"
             "arms_factory" -> MsgAddBuildingConstruction (iconText "mic")
             "dockyard" -> MsgAddBuildingConstruction (iconText "nic")
             "bunker" -> MsgAddBuildingConstruction (iconText "land fort")
-            _ -> MsgAddBuildingConstruction (iconText _type)            
+            _ -> MsgAddBuildingConstruction (iconText _type)
          ) buildingLoc _level "check files if bunker"
     |]
 
diff --git a/src/HOI4/Templates.hs b/src/HOI4/Templates.hs
index dba582b..c62cf9d 100644
--- a/src/HOI4/Templates.hs
+++ b/src/HOI4/Templates.hs
@@ -84,7 +84,7 @@ foldCompound :: String -> String -> String -> [(String, Q Type)] -> [CompField]
 foldCompound funname s_tyname prefix extraArgs fieldspecs eval = do
     let -- Missing TH library function
         funT :: TypeQ -> TypeQ -> TypeQ
-        funT t1 t2 = [t| $t1 -> $t2 |] 
+        funT t1 t2 = [t| $t1 -> $t2 |]
         -- Variable names
         name_acc = mkName "acc"
         name_addLine = mkName "addLine"
@@ -151,7 +151,7 @@ foldCompound funname s_tyname prefix extraArgs fieldspecs eval = do
             dataD (cxt []) tyname [] Nothing
                   [recC tyname recFields
                   ]
-                  (cxt [])
+                  [DerivClause Nothing <$> cxt []]
         -- Initial accumulator
         -- new<AccType> :: <AccType>
         -- new<AccType> = AccType <default1> <default2> ...
diff --git a/src/QQ.hs b/src/QQ.hs
index ac3227f..ef39622 100644
--- a/src/QQ.hs
+++ b/src/QQ.hs
@@ -60,7 +60,7 @@ In a pattern:
         @
 
         * @$foo@ => @foo :: Text@, matches a bare_word
-        
+
         * @!foo@ => @foo :: Int@, matches a number (goes through @floatRhs@)
 
     * on the RHS only:
@@ -100,7 +100,6 @@ import Language.Haskell.TH -- everything
 import qualified Language.Haskell.TH.Lift as TL
 import Language.Haskell.TH.Quote (QuasiQuoter (..))
 import Instances.TH.Lift ()
---import Language.Haskell.Exts.QQ
 import Language.Haskell.Meta (parseExp, parsePat)
 
 import Abstract
diff --git a/src/Stellaris/Common.hs b/src/Stellaris/Common.hs
index ecd8e50..e37cddb 100644
--- a/src/Stellaris/Common.hs
+++ b/src/Stellaris/Common.hs
@@ -844,7 +844,7 @@ random :: (StellarisInfo g, Monad m) =>
     GenericStatement -> PPT g m IndentedMessages
 random stmt@[pdx| %_ = @scr |]
     | (front, back) <- break
-                        (\substmt -> case substmt of 
+                        (\substmt -> case substmt of
                             [pdx| chance = %_ |] -> True
                             _ -> False)
                         scr
@@ -921,7 +921,8 @@ triggerSwitch stmt@(Statement _ OpEq (CompoundRhs
         [pdx| $condrhs = @action |] -> do
             -- construct a fake condition to pp
             let cond = [pdx| $condlhs = $condrhs |]
-            ((_, guardMsg):_) <- ppOne cond -- XXX: match may fail (but shouldn't)
+            cond' <- ppOne cond
+            let ((_, guardMsg):_) = cond' -- XXX: match may fail (but shouldn't)
             guardText <- messageText guardMsg
             -- pp the rest of the block, at the next level
             statementMsgs <- indentUp (ppMany action)
diff --git a/src/Stellaris/Events.hs b/src/Stellaris/Events.hs
index 4c72b66..96c0c28 100644
--- a/src/Stellaris/Events.hs
+++ b/src/Stellaris/Events.hs
@@ -52,7 +52,7 @@ parseStellarisEvents = HM.unions . HM.elems <$> do
         HM.traverseWithKey
             (\sourceFile scr ->
                 setCurrentFile sourceFile $ mapM parseStellarisEvent scr)
-            scripts 
+            scripts
     case tryParse of
         Left err -> do
             traceM $ "Completely failed parsing events: " ++ T.unpack err
@@ -292,7 +292,7 @@ pp_event evt = case stevt_id evt of
             evtArg fieldname field fmt
                 = maybe (return [])
                     (\field_content -> do
-                        content_pp'd <- fmt field_content 
+                        content_pp'd <- fmt field_content
                         return
                             ["| ", Doc.strictText fieldname, " = "
                             ,PP.line
